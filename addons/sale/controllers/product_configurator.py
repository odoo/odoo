# Part of Odoo. See LICENSE file for full copyright and licensing details.


from datetime import datetime

from odoo.http import request, route
from odoo.addons.product.controllers.product_configurator import ProductConfiguratorController


class SaleProductConfiguratorController(ProductConfiguratorController):

    @route()
    def get_product_configurator_values(
        self,
        product_template_id,
        company_id=None,
        ptav_ids=None,
        **kwargs
    ):
        """ Override of `product` to return a list of optional products if it is needed.

        The list of optional products is returned if the model showing the product configurator is
        a `sale.order` and if `only_main_product` is not True.

        :param int product_template_id: The product for which to seek information, as a
                                        `product.template` id.
        :param int|None company_id: The company to use, as a `res.company` id.
        :param recordset|None ptav_ids: The combination of the product, as a
                                        `product.template.attribute.value` recordset.
        :param dict kwargs: Additional values useful to compute sales-specific values.
        :rtype: dict
        :return: A dict containing a list of products information, generated by
                 :meth:`_get_product_information`.
        """
        product_configurator_values = super().get_product_configurator_values(
            product_template_id,
            company_id=company_id,
            ptav_ids=ptav_ids,
            **kwargs
        )
        is_sale_order = kwargs.get('model') == 'sale.order'

        if is_sale_order:
            product_configurator_values = {
                "products": [
                    dict(item, parent_product_tmpl_ids=[])
                ] for item in product_configurator_values["products"]
            }

        if not is_sale_order or (is_sale_order and kwargs.get('only_main_product')):
            return product_configurator_values

        product_template = request.env['product.template'].browse(product_template_id)
        combination = request.env['product.template.attribute.value']
        if ptav_ids:
            combination = request.env['product.template.attribute.value'].browse(ptav_ids).filtered(
                lambda ptav: ptav.product_tmpl_id.id == product_template_id
            )
        if not combination:
            combination = product_template._get_first_possible_combination()
        product_configurator_values.update({
            "optional_products":
                self._get_optional_product(
                    product_template,
                    combination,
                    **kwargs
                )
        })
        return product_configurator_values

    @route('/product_configurator/get_optional_products', type='json', auth='user')
    def product_configurator_get_optional_products(
        self,
        product_template_id,
        combination,
        parent_combination,
        company_id=None,
        **kwargs
    ):
        """ Return information about optional products for a given `product.template`.

        :param int product_template_id: The product for which to seek information, as a
                                        `product.template` id.
        :param recordset combination: The combination of the product, as a
                                      `product.template.attribute.value` recordset.
        :param recordset parent_combination: The combination of the parent product, as a
                                             `product.template.attribute.value` recordset.
        :param int|None company_id: The company to use, as a `res.company` id.
        :param dict kwargs: Additional values useful to compute sales-specific values.
        :rtype: [dict]
        :return: A list of optional products information, generated by
                 :meth:`_get_product_information`.
        """
        if company_id:
            request.update_context(allowed_company_ids=[company_id])
        product_template = request.env['product.template'].browse(product_template_id)
        parent_combination = request.env['product.template.attribute.value'].browse(
            parent_combination + combination
        )
        return [{
            **self._get_product_information(
                optional_product_template,
                optional_product_template._get_first_possible_combination(
                    parent_combination=parent_combination
                ),
                parent_combination=parent_combination, # TODO VCR why ?
                **kwargs
            ),
            'parent_product_tmpl_ids': [product_template.id],
        } for optional_product_template in product_template.optional_product_ids]

    def _get_optional_product(self, product_template, combination, **kwargs):
        """ Return a dict of optional products based on a product_template and a combination.

        :param recordset product_template: The product for which to seek information, as a
                                        `product.template`.
        :param recordset combination: The combination of the product, as a
                                      `product.template.attribute.value` recordset.
        :param dict kwargs: Additional values useful to compute sales-specific values.
        :rtype: dict
        :return: optional products
        """
        return [dict(
            **self._get_product_information(
                optional_product_template,
                optional_product_template._get_first_possible_combination(
                    parent_combination=combination
                ),
                # giving all the ptav of the parent product to get all the exclusions
                parent_combination=product_template.attribute_line_ids.\
                    product_template_value_ids,
                **kwargs,
            ),
            parent_product_tmpl_ids=[product_template.id],
        ) for optional_product_template in product_template.optional_product_ids]

    def _get_product_information(
        self,
        product_template,
        combination,
        **kwargs
    ):
        """ Override of `product` to add the parent exclusions in the information returned.

        The parent exclusions are only included if the model showing the product configurator is
        `sale.order`.

        :param recordset product_template: The product for which to seek information, as a
                                           `product.template` record.
        :param recordset combination: The combination of the product, as a
                                      `product.template.attribute.value` recordset.
        :param dict kwargs: Additional values useful to compute sales-specific values.
        :rtype: dict
        :return: A dict with the following structure:
            {
                'product_tmpl_id': int,
                **self._get_basic_product_information(): See method's return for more info
                'attribute_line': [{
                    'id': int
                    'attribute': {
                        'id': int
                        'name': str
                        'display_type': str
                    },
                    'attribute_value': [{
                        'id': int,
                        'name': str,
                        'html_color': str|False,
                        'image': str|False,
                        'is_custom': bool,
                        **self._get_additional_attribute_values_information(): See method's return for more info,
                    }],
                    'selected_attribute_id': int,
                }],
                'exclusions': dict,
                'archived_combination': dict,
                'parent_exclusions': dict,
            }
        """
        product_information = super()._get_product_information(
            product_template,
            combination,
            **kwargs
        )
        if kwargs.get('model') != 'sale.order':
            return product_information

        parent_exclusions = product_template._get_parent_attribute_exclusions(
            parent_combination=kwargs.get('parent_combination')
        )

        return {
            **product_information,
            'parent_exclusions': parent_exclusions,
        }

    def _get_basic_product_information(self, product_or_template, combination, **kwargs):
        """ Override of `product` to add the price in the information returned.

        The price is only included if the model showing the product configurator is `sale.order`.

        :param recordset product_or_template: The product for which to seek information, as a
                                              `product.product` or `product.template` record.
        :param recordset combination: The combination of the product, as a
                                      `product.template.attribute.value` recordset.
        :param dict kwargs: Additional values useful to compute sales-specific values.
        :rtype: dict
        :return: A dict with the following structure::
            {
                'id': int,  # if `product_or_template` is a record of `product.product`.
                'description_sale': str|False,
                'display_name': str,
                'price': float
                'quantity': int,  # if `quantity` is defined in `kwargs`.
            }
        """
        basic_product_information = super()._get_basic_product_information(
            product_or_template, combination, **kwargs
        )
        if kwargs.get('model') != 'sale.order':
            return basic_product_information

        pricelist = request.env['product.pricelist'].browse(kwargs.get('pricelist_id'))
        return {
            **basic_product_information,
            'price': pricelist._get_product_price(
                product_or_template.with_context(
                    **product_or_template._get_product_price_context(combination)
                ),
                quantity=kwargs.get('quantity'),
                uom=request.env['uom.uom'].browse(kwargs.get('product_uom_id')),
                currency=request.env['res.currency'].browse(kwargs.get('currency_id')),
                date=datetime.fromisoformat(kwargs.get('so_date')),
            ),
        }

    def _get_additional_attribute_values_information(self, ptav, **kwargs):
        """ Override of `product` to add the extra price on the ptav.

        The extra price is only included if the model showing the product configurator is
        `sale.order`.

        :param record ptav: The attribute value, as a `product.template.attribute.value` record.
        :return: The additional attribute values information.
        :rtype: dict
        """
        additional_ptav_information = super()._get_additional_attribute_values_information(
            ptav, **kwargs
        )
        if kwargs.get('model') != 'sale.order':
            return additional_ptav_information

        currency = request.env['res.currency'].browse(kwargs.get('currency_id'))
        return {
            **additional_ptav_information,
            'price_extra': ptav.currency_id._convert(
                ptav.price_extra,
                currency,
                request.env.company,
                datetime.fromisoformat(kwargs.get('so_date')).date()
            ),
        }
