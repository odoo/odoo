# Part of Odoo. See LICENSE file for full copyright and licensing details.
import itertools
from pytz import timezone, utc

from collections import defaultdict
from datetime import date, datetime
from dateutil.relativedelta import relativedelta

from odoo import _, api, models, fields
from odoo.exceptions import ValidationError
from odoo.tools.intervals import Intervals
from odoo.tools.intervals import _boundaries


def _replace_interval_records(intervals, records):
    return Intervals((start, end, records) for (start, end, _) in intervals)

def _record_overlap_intervals(interval_sets):
    boundaries = sorted(_boundaries(itertools.chain(*interval_sets), 'start', 'stop'))
    counts = {}
    interval_vals = []
    ids = set()
    for (time, flag, records) in boundaries:
        for record in records:
            if (
                new_count := counts.get(record.id, 0) + {'start': 1, 'stop': -1}[flag]
            ):
                counts[record.id] = new_count
            else:
                del counts[record.id]
        new_ids = set(counts.keys())
        if ids != new_ids:
            if ids:
                interval_vals.append((start, time, records.browse(ids)))
            if new_ids:
                start = time
        ids = set(new_ids)
    return Intervals(interval_vals, keep_distinct=True)

def _last_hours_as_intervals(starting_intervals, hours, records=set()):
    last_hours_intervals = []
    for (start, stop, _) in reversed(starting_intervals):
        duration = (stop - start).seconds / 3600
        if hours >= duration:
            last_hours_intervals.append((start, stop, records))
            hours -= duration
        elif hours > 0:
            last_hours_intervals.append((stop - relativedelta(hours=hours), stop, records))
            break
        else:
            break
    return Intervals(last_hours_intervals)


class HrAttendanceOvertimeRule(models.Model):
    _name = 'hr.attendance.overtime.rule'
    _description = "Overtime Rule"

    name = fields.Char(required=True)
    base_off = fields.Selection([
            ('quantity', "Quantity"),
            ('timing', "Timing"),
        ],
        string="Based Off",
        required=True,
        default='quantity',
        help="Controls how what counts as overtime is determined",
    )

    working_hours_from_contract = fields.Boolean(default=True) # TODO string=

    working_hours = fields.Float(string="Usual work hours")
    work_schedule = fields.Many2one('resource.calendar')

    quantity_period = fields.Selection([('day', 'Daily'), ('week', 'Weekly')], default='day')

    @api.constrains('base_off', 'working_hours', 'check_out', 'quantity_period')
    def _check_working_hours(self):
        for rule in self:
            if (
                rule.base_off == 'quantity' 
                and not rule.working_hours_from_contract
                and not rule.working_hours
            ):
                raise ValidationError(self.env._("Rule '%(name)s' is based off quantity, but the usual amount of work hours is not specified"), name=rule.name)

            if rule.base_off == 'quantiy' and not rule.quantity_period:
                raise ValidationError(self.env._("Rule '%(name)s' is based off quantity, but the period is not specified"), name=rule.name)

    @api.constrains('base_off', 'working_hours', 'check_out')
    def _check_work_schedule(self):
        for rule in self:
            if (
                rule.base_off == 'timing' 
                and not rule.working_hours_from_contract
                and not rule.work_schedule
            ):
                raise ValidationError(self.env._("Rule %(name)s is based off timing, but the usual work times are not specified"))

    def _get_overtime_intervals(self, employee, attendances, tz):
        """ return all overtime over the attendances (all of the SAME employee)
            as a list of `Intervals` sets with the rule as the recordset
            generated by `timing` rules in self 
        """
        # Timing based
        if not attendances:
            return [Intervals(keep_distinct=True)]

        attendances.employee_id.ensure_one()

        # TODO problems with lunch
        attendance_intervals = Intervals((att.check_in, att.check_out, set()) for att in attendances)
        
        timing_intervals_list = []
        start_dt = min((start for start, _, _ in attendance_intervals))
        end_dt = max((end for _, end, _ in attendance_intervals))


        for rule in self.filtered(lambda r: r.base_off == 'timing'):
            if rule.working_hours_from_contract: # TODO extract in method to get intervals
                pass
            else:
                work_schedule = rule.work_schedule
            
            #breakpoint()
            def naive_utc(dt):
                return dt.astimezone(utc).replace(tzinfo=None)

            work_intervals = Intervals(
                (naive_utc(start), naive_utc(end), records) 
                for (start, end, records) 
                in work_schedule._attendance_intervals_batch(utc.localize(start_dt), utc.localize(end_dt))[False]
                | work_schedule._attendance_intervals_batch(utc.localize(start_dt), utc.localize(end_dt), lunch=True)[False])

            timing_intervals_list.append(
                _replace_interval_records(attendance_intervals, rule)
                - work_intervals)

        timing_overtime_intervals = _record_overlap_intervals(timing_intervals_list)

        # Quantity Based
        periods = ['day', 'week']
        def get_period_keys(dt, tz):
            day = dt.astimezone(tz).date()
            return {
                'day': day,
                'week': day - relativedelta(days=day.weekday()),
            }

        work_hours_by = {period: defaultdict(lambda: 0) for period in periods}
        intervals_by = {period: defaultdict(list) for period in periods}
        overtime_hours_by = {period: defaultdict(lambda: 0) for period in periods}
        timing_overtimes_by = {period: defaultdict(list) for period in periods}
        for attendance in attendances:
            for period, key in get_period_keys(attendance.check_in, tz).items():
                work_hours_by[period][key] += attendance.worked_hours
                intervals_by[period][key].append(
                    (attendance.check_in, attendance.check_out, set())
                )
        for start, end, _ in timing_overtime_intervals:
            for period, key in get_period_keys(start, tz).items():
                overtime_hours_by[period][key] = (end - start).seconds / 3600
                timing_overtimes_by[period][key].append((start, end, set()))

        quantity_intervals_list = []
        for rule in self.filtered(lambda r: r.base_off == 'quantity'):
            period = rule.quantity_period
            expected_hours = rule.working_hours # TODO extract method to get hours
            for date in intervals_by[period]:
                overtime_quantity = work_hours_by[period][date] - expected_hours
                if overtime_quantity <= 0:
                    continue  # TODO handle negative
                elif overtime_quantity < overtime_hours_by[period][date]:
                    quantity_intervals_list.append(_last_hours_as_intervals(
                        starting_intervals=timing_overtimes_by[period][date],
                        hours=overtime_quantity,
                        records=rule,
                    ))
                else:
                    quantity_intervals_list.append(_last_hours_as_intervals(
                        starting_intervals=intervals_by[period][date],
                        hours=overtime_quantity-overtime_hours_by[period][date],
                        records=rule,
                    ) | _replace_interval_records(timing_overtimes_by[period][date], rule))
        #for intervals in [timing_overtime_intervals, *quantity_intervals_list]:
        #   print(*intervals, sep='\n')
        return _record_overlap_intervals([timing_overtime_intervals, *quantity_intervals_list])

    @api.model
    def _get_attendance_group_boundaries(self, attendances, employee_timezones=None):
        employee_timezones = employee_timezones or attendances.employee_id._get_calendar_tz_batch(min(attendances.mapped('check_in')))

        def localized_check_in(attendance):
            tz = timezone(employee_timezones[attendance.employee_id.id])
            return tz.localize(attendance.check_in)

        # start on last monday before date_start, end on first sunday after
        date_start = min(localized_check_in(att).date() for att in attendances)
        date_start -= relativedelta(days=date_start.weekday())
        # use `check_in` for date_end too, bc we always consider an attendance to be for the date of the check_in
        date_end = max(localized_check_in(att).date() for att in attendances)
        date_end += relativedelta(days=6-date_end.weekday())

        return date_start, date_end

    @api.model
    def _get_attendance_group_by_employee(self, attendances, employee_timezones=None):
        """ Given `attendances`, return a dict { employee_timezone: attendances }
            of all attendances that can "interact" with an attendance 
            in the original set when computing overtimes.
            i.e. all attendances that happen in the same week for a same employee.
        """
        def naive_utc(dt):
            return dt.astimezone(utc).replace(tzinfo=None)

        employees = attendances.employee_id

        employee_timezones = employee_timezones or employees._get_calendar_tz_batch(min(attendances.mapped('check_in')))
        tzset = set(timezone(tz) for tz in employee_timezones.values())
        
        date_start, date_end = self._get_attendance_group_boundaries(attendances, employee_timezones)

        # Assume the employee doesn't change timezone between date_start and date_end
        datetime_start = min(tz.localize(datetime.combine(date_start, datetime.min.time())) for tz in tzset)
        datetime_end = min(tz.localize(datetime.combine(date_end, datetime.max.time())) for tz in tzset)

        attendances_by_employee = {}
        for employee, employee_attendances in self.env['hr.attendance'].search([
            ('check_in', '>=', naive_utc(datetime_start)),
            ('check_out', '<=', naive_utc(datetime_end)),
            ('employee_id', 'in', employees.ids),
        ]).grouped('employee_id').items():
            # Remove irrelevant attendances for the employee timezone
            tz_name = employee_timezones[employee.id]
            tz = timezone(tz_name)
            attendances_by_employee[employee] = employee_attendances.filtered(
                lambda att: datetime_start.replace(tzinfo=tz) <= utc.localize(att.check_in) <= datetime_end.replace(tzinfo=tz)
            )

        return attendances_by_employee

    def process_rules(self, attendances, employee_timezones=None):
        employee_timezones = employee_timezones or attendances.employee_id._get_calendar_tz_batch(min(attendances.mapped('check_in')))

        vals_list = []
        attendances_by_employee = self._get_attendance_group_by_employee(attendances, employee_timezones)
        for employee, attendances in attendances_by_employee.items():
            tz = timezone(employee_timezones[employee.id])
            intervals = self._get_overtime_intervals(employee, attendances, tz)
            print(*intervals, sep='\n')
            vals_list.extend({
                'time_start': start,
                'time_stop': stop,
                'duration': (stop - start).seconds / 3600,
                'employee_id': employee.id,
                'date': start.astimezone(tz).date(),
                **rules._extra_overtime_vals(), # pay_rate, give_as_time_off
                } for start, stop, rules in intervals
            )

        print(*vals_list, sep='\n')
        self.env['hr.attendance.overtime.line'].create(vals_list)

    def _extra_overtime_vals(self):
        return {}
