# Part of Odoo. See LICENSE file for full copyright and licensing details.
import itertools
import pytz

from collections import defaultdict
from datetime import date, datetime
from dateutil.relativedelta import relativedelta

from odoo import _, api, models, fields
from odoo.exceptions import ValidationError
from odoo.tools.intervals import Intervals
from odoo.tools.intervals import _boundaries


def _replace_interval_records(intervals, records):
    return Intervals((start, end, records) for (start, new, _) in intervals)

def _record_overlap_intervals(interval_sets):
    boundaries = sorted(_boundaries(itertools.chain(*interval_sets), 'start', 'stop'))
    counts = {}
    interval_vals = []
    ids = set()
    for (time, flag, records) in boundaries:
        for record in records:
            if (
                new_count := counts.get(record.id, 0) + {'start': 1, 'stop': -1}[flag]
            ):
                counts[record.id] = new_count
            else:
                del counts[record.id]
        new_ids = set(counts.keys())
        if ids != new_ids:
            if ids:
                interval_vals.append((start, time, records.browse(ids)))
            if new_ids:
                start = time
        ids = set(new_ids)
    return Intervals(interval_vals, keep_distinct=True)

def _last_hours_as_intervals(starting_intervals, hours, records=set()):
    last_hours_intervals = []
    for (start, stop, _) in reversed(starting_intervals):
        duration = (stop - start) / 3600
        if hours >= duration:
            last_hours_intervals.append((start, stop, records))
            hours -= duration
        elif hours > 0:
            last_hours_intervals.append((stop - relativedelta(hours), stop, records))
            break
        else:
            break
    return last_hours_intervals


class HrAttendanceOvertimeRule(models.Model):
    _name = 'hr.attendance.overtime.rule'
    _description = "Overtime Rule"

    name = fields.Char(required=True)
    base_off = fields.Selection([
            ('quantity', "Quantity"),
            ('timing', "Timing"),
        ],
        string="Based Off",
        required=True,
        default='quantity',
        help="Controls how what counts as overtime is determined",
    )

    working_hours_from_contract = fields.Boolean(default=True) # TODO string=

    working_hours = fields.Float(string="Usual work hours")
    work_schedule = fields.Many2one('resource.calendar')

    quantity_period = fields.Selection([('day', 'Daily'), ('week', 'Weekly')], default='day')

    @api.constrains('base_off', 'working_hours', 'check_out', 'quantity_period')
    def _check_working_hours(self):
        for rule in self:
            if (
                rule.base_off == 'quantity' 
                and not rule.working_hours_from_contract
                and not rule.working_hours
            ):
                raise ValidationError(self.env._("Rule '%(name)s' is based off quantity, but the usual amount of work hours is not specified"), name=rule.name)

            if rule.base_off == 'quantiy' and not rule.quantity_period:
                raise ValidationError(self.env._("Rule '%(name)s' is based off quantity, but the period is not specified"), name=rule.name)

    @api.constrains('base_off', 'working_hours', 'check_out')
    def _check_work_schedule(self):
        for rule in self:
            if (
                rule.base_off == 'timing' 
                and not rule.working_hours_from_contract
                and not rule.work_schedule
            ):
                raise ValidationError(self.env._("Rule %(name)s is based off timing, but the usual work times are not specified"))

    def get_timing_overtime_intervals_list(self, attendances):
        """ return all overtime over the attendances (all of the SAME employee)
            as a list of `Intervals` sets with the rule as the recordset
            generated by `timing` rules in self 
        """
        if not attendances:
            return [Intervals(keep_distinct=True)]

        attendances.employee_id.ensure_one()

        # TODO problems with lunch
        attendance_intervals = Intervals((att.check_in, att.check_out, set()) for att in attendances)
        
        intervals_list = []
        start_dt = min((start for start, _, _ in attendance_intervals))
        end_dt = max((end for _, end, _ in attendance_intervals))

        for rule in self.filtered(lambda r: r.base_off == 'timing'):
            if rule.work_schedule_from_contract: # TODO extract in method to get intervals
                pass
            else:
                work_schedule = rule.work_schedule
            
            intervals_list.append(
                _replace_interval_records(attendance_intervals, rule)
                - work_schedule._get_work_intervals(start_dt, end_dt))
        return intervals_list

    def get_quantity_overtime_intervals_list(self, attendances, tz):
        attendances.employee_id.ensure_one()

        work_hours_by_day = defaultdict(lambda: 0)
        work_hours_by_week = defaultdict(lambda: 0)
        intervals_by_day = defaultdict(list)
        intervals_by_week = defaultdict(list)
        for attendance in attendances:
            day = attendance.check_in.astimezone(tz).date()
            monday = day - relativedelta(days=day.weekday())
            work_hours_by_day[day] += attendance.worked_hours
            work_hours_by_week[monday] += attendance.worked_hours
            intervals_by_day[day].append(
                (attendance.check_in, attendance.check_out, set())
            ) 
            intervals_by_week[monday].append(
                (attendance.check_in, attendance.check_out, set())
            ) 
        intervals_by_day = {
            day: Intervals(tuples) for day, tuples in intervals_by_day.items()
        }
        intervals_by_week = {
            week: Intervals(tuples) for week, tuples in intervals_by_week.items()
        }

        intervals_list = []
        for rule in self.filtered(lambda r: r.base_off == 'quantity'):
            if rule.quantity_period == 'week':
                expected_hours = rule.working_hours # TODO extract method to get hours
                for week, intervals in intervals_by_week.items():
                    intervals_list.append(_last_hours_as_intervals(
                        starting_intervals=intervals,
                        hours=rule.working_hours - work_hours_by_week[week],
                        records=rule,
                    ))
            if rule.quantity_period == 'day':
                expected_hours = rule.working_hours
                for day, intervals in intervals_by_day.items():
                    intervals_list.append(_last_hours_as_intervals(
                        starting_intervals=intervals,
                        hours=rule.working_hours - work_hours_by_day[day],
                        records=rule,
                    ))
        return intervals_list

    @api.model
    def _get_attendance_group(self, employees, date_start, date_end=None):
        """ Get the attendances for `employees` between date_start and date_end
            and all those that are "linked" to them in the sense that they can
            affect the overtime computation.
            (i.e. all attendances in the same week)
        """
        # start on last monday before date_start, end on first sunday after
        date_end = date_end or date_start
        date_start -= relativedelta(days=date_start.weekday())
        date_end += relativedelta(days=6-date_end.weekday())

        # Assume the employee doesn't change timezone between date_start and date_end
        datetime_start = datetime.combine(date_start, datetime.min.time())
        employee_timezones = employees._get_calendar_tz_batch(datetime_min)
        # fetch all attendances where the start is between
        # date_start in the timezone where midignight is earliest
        # and the day after date_end in the timezone where midnight is the latest
        datetime_min = min(
            datetime_min.replace(tzinfo=tz) 
            for tz in employee_timezones.values())
        datetime_max = max(
            datetime.combine(date_end, datetime.max.time()).replace(tzinfo=tz)
            for tz in employee_timezones.values())
        all_attendances = self.env.search([
            ('date_start', '>=', datetime_min),
            ('date_end', '<=', datetime_max),
            ('employee_id', 'in', employees.ids),
        ])

    @api.model
    def _get_attendance_group_by_tz(attendances):
        """ Given `attendances`, return a dict { employee timezone: attendances }
            of all attendances that can "interact" with an attendance in the original set
            when computing overtimes.
            i.e. all attendances that happen in the same week for a same employee
        """
        employees = attendances.employee_ids

        employee_timezones = employees._get_calendar_tz_batch(datetime_start)
        tzset = set(pytz.timezone(tz) for tz in employee_timezones.values())

        # start on last monday before date_start, end on first sunday after
        date_start = min(att.check_in.astimezone(employee_timezones[att.employee_id.id]).date())
        date_start -= relativedelta(days=date_start.weekday())
        # use `check_in` for date_end too, bc we always consider an attendance to be for the date of the check_in
        date_end = max(att.check_in.astimezone(employee_timezones[att.employee_id.id]).date())
        date_end += relativedelta(days=6-date_end.weekday())

        datetime_start = datetime.combine(date_start, datetime.min.time())
        datetime_end = datetime.combine(date_end, datetime.max.time())

        attendances_by_tz = {}
        for employee, employee_attendances in self.env['hr.attendance'].search([
            ('check_in', '>=', datetime_min),
            ('check_out', '<=', datetime_max),
            ('employee_id', 'in', employees.ids),
        ]).grouped('employee_id').items():
            # Remove irrelevant attendances for the employee timezone
            tz_name = employee_timezones[employee.id]
            tz = pytz.timezone(tz_name)
            employee_attendances = employee_attendances.filtered(
                lambda att: datetime_start.replace(tzinfo=tz) <= att.check_in <= datetime_end.replace(tzinfo=tz)
            )

            attendances_by_tz[tz_name] = attendances_by_tz.get(tz_name, self.env['hr.attendance']) | attendances

        return attendances_by_tz


    def process_rules(self, attendances):
        attendances_by_tz = self._get_attendance_group_by_tz(attendances)
        for tz_name, attendances in attendances_by_tz.items():
            tz = pytz.timezone(tz_name)

            intervals_list = self.get_timing_overtime_intervals_list(attendances)
            intervals_list.extend(self.get_quantity_overtime_intervals_list(attendances, tz))
            vals_list.extend({
                'time_start': start,
                'time_stop': stop,
                'duration': (stop - start).hours,
                'employee_id': employee.id,
                'date': start.astimezone(tz).date(),
                **rules._extra_overtime_vals(), # pay_rate, give_as_time_off
                } for start, stop, rules in _record_overlap_intervals(intervals_list)
            )

        self.env['hr.attendance.overtime.line'].create(vals_list)

    def _extra_overtime_vals(self):
        return {}
