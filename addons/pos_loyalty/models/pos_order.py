# Part of Odoo. See LICENSE file for full copyright and licensing details.
import base64

from collections import defaultdict
from markupsafe import Markup

from odoo import api, fields, models, _
from odoo.tools import float_compare


class PosOrder(models.Model):
    _inherit = 'pos.order'

    loyalty_card_ids = fields.Many2many(
        comodel_name='loyalty.card', string="Loyalty Cards",
        help="The coupons generated by this order.")

    def validate_coupon_programs(self, point_changes, new_codes):
        """
        This is called upon validating the order in the pos.

        This will check the balance for any pre-existing coupon to make sure that the rewards are in fact all claimable.
        This will also check that any set code for coupons do not exist in the database.
        """
        point_changes = {int(k): v for k, v in point_changes.items()}
        coupon_ids_from_pos = set(point_changes.keys())
        coupons = self.env['loyalty.card'].browse(coupon_ids_from_pos).exists().filtered('program_id.active')
        coupon_difference = set(coupons.ids) ^ coupon_ids_from_pos
        if coupon_difference:
            return {
                'successful': False,
                'payload': {
                    'message': _('Some coupons are invalid. The applied coupons have been updated. Please check the order.'),
                    'removed_coupons': list(coupon_difference),
                }
            }
        for coupon in coupons:
            if float_compare(coupon.points, -point_changes[coupon.id], 2) == -1:
                return {
                    'successful': False,
                    'payload': {
                        'message': _('There are not enough points for the coupon: %s.', coupon.code),
                        'updated_points': {c.id: c.points for c in coupons}
                    }
                }
        # Check existing coupons
        coupons = self.env['loyalty.card'].search([('code', 'in', new_codes)])
        if coupons:
            return {
                'successful': False,
                'payload': {
                    'message': _('The following codes already exist in the database, perhaps they were already sold?\n%s',
                        ', '.join(coupons.mapped('code'))),
                }
            }
        return {
            'successful': True,
            'payload': {},
        }

    def _add_loyalty_history_lines(self, history_vals, updated_loyalty_cards, loyalty_cards_before):
        orders = self.browse({c['order_id'] for c in updated_loyalty_cards}).exists()
        order_display_name_map = {o.id: o.display_name for o in orders}
        for card in updated_loyalty_cards:
            card_id = card['id']
            order_display_name = order_display_name_map.get(card['order_id'])
            before = loyalty_cards_before.get(card_id, 0)
            points = card['points'] - before
            if not order_display_name or not points:
                continue
            history_vals.append({
                'card_id': card_id,
                'order_model': self._name,
                'order_id': card['order_id'],
                'description': _('Onsite %s', order_display_name),
                'used': 0,
                'issued': points,
            })
        if history_vals:
            self.env['loyalty.history'].create(history_vals)

    @api.model
    def sync_from_ui(self, orders):
        """
        Synchronize orders from POS UI and process loyalty cards and points.
        Tracks loyalty cards before sync, deducts points for rewards, and creates loyalty history.
        Returns synced data including updated loyalty cards and programs.
        """
        loyalty_cards_before = {}
        updated_loyalty_cards = []
        skip_deduction = False
        LoyaltyCard = self.env['loyalty.card']
        order_card_map = defaultdict(lambda: LoyaltyCard)
        for order in orders:
            skip_deduction = skip_deduction or order.get('is_refund', False)
            for _command, card_id, card_vals in order.get('loyalty_card_ids', []):
                if card_id:
                    order_token = order['access_token']
                    card = LoyaltyCard.browse(card_id).exists()
                    if card:
                        order_card_map[order_token] |= card
                        loyalty_cards_before[card.id] = card.points
                card_vals['code'] = card_vals['code'] or LoyaltyCard._generate_code()

        data = super().sync_from_ui(orders)
        created_orders = self.browse([order['id'] for order in data['pos.order'] if order.get('id')])
        for order in created_orders:
            order.loyalty_card_ids |= order_card_map.get(order.access_token, LoyaltyCard)
            for loyalty_card in order.loyalty_card_ids:
                updated_loyalty_cards.append({'order_id': order.id, 'id': loyalty_card.id, 'points': loyalty_card.points})
            order._add_log_for_gift_cards(order.loyalty_card_ids.filtered(lambda c: c.program_type == 'gift_card'))
        history_vals = []
        if not skip_deduction:
            for line in created_orders.filtered(lambda o: not o.is_refund).lines.filtered('coupon_id'):
                coupon = line.coupon_id
                correction = (
                    line._points_for_correction()
                    if coupon.program_type not in (
                        'coupons', 'promo_code', 'gift_card', 'next_order_coupons',
                    )
                    else 0
                )
                history_vals.append({
                    'card_id': coupon.id,
                    'order_model': line.order_id._name,
                    'order_id': line.order_id.id,
                    'description': _('Onsite %s', line.order_id.display_name),
                    'used': line.points_cost,
                    'issued': 0,
                })
                coupon.points -= (line.points_cost + correction)
        self._add_loyalty_history_lines(history_vals, updated_loyalty_cards, loyalty_cards_before)
        created_orders.loyalty_card_ids.with_context(action_no_send_mail=False)._send_creation_communication()
        all_cards = created_orders.loyalty_card_ids | created_orders.lines.coupon_id
        loyalty_cards = [{**loyalty_card, '_barcode_base64': 'data:image/png;base64,' + base64.b64encode(self.env['ir.actions.report'].barcode('Code128', loyalty_card.get('code'))).decode('utf-8')} for loyalty_card in LoyaltyCard._load_pos_data_read(all_cards, created_orders[0].config_id)]
        data.update({
            'loyalty.card': loyalty_cards,
            'loyalty.program': self.env['loyalty.program']._load_pos_data_read(
                all_cards.program_id, created_orders[0].config_id,
            ),
        })

        return data

    def _add_log_for_gift_cards(self, gift_cards):
        body = Markup(
            """
                <span class='o-mail-Message-trackingOld text-muted fw-bold'>{message}<span/>
                <i class='o-mail-Message-trackingSeparator fa fa-long-arrow-right mx-1 text-600'/>
                <span class='o-mail-Message-trackingNew text-info fw-bold'>{order_name}</span>
            """
        ).format(message=_('Loyalty coupon sold'), order_name=self._get_html_link())
        for gift_card in gift_cards:
            gift_card.message_post(body=body)

    def _add_mail_attachment(self, name, ticket, basic_receipt):
        attachment = super()._add_mail_attachment(name, ticket, basic_receipt)
        gift_card_programs = self.config_id._get_program_ids().filtered(lambda p: p.program_type == 'gift_card' and
                                                                                  p.pos_report_print_id)
        if gift_card_programs:
            gift_cards = self.env['loyalty.card'].search([('source_pos_order_id', '=', self.id),
                                                          ('program_id', 'in', gift_card_programs.ids)])
            if gift_cards:
                for program in gift_card_programs:
                    filtered_gift_cards = gift_cards.filtered(lambda gc: gc.program_id == program)
                    if filtered_gift_cards:
                        action_report = program.pos_report_print_id
                        report = action_report._render_qweb_pdf(action_report.report_name, filtered_gift_cards.ids)
                        filename = name + '.pdf'
                        gift_card_pdf = self.env['ir.attachment'].create({
                            'name': filename,
                            'type': 'binary',
                            'raw': report[0],
                            'store_fname': filename,
                            'res_model': 'pos.order',
                            'res_id': self.ids[0],
                            'mimetype': 'application/x-pdf'
                        })
                        attachment += [(4, gift_card_pdf.id)]

        return attachment
