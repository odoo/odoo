# -*- coding: utf-8 -*-

from datetime import datetime
import hashlib
from urllib import urlencode

from openerp import models, fields, api


class Users(models.Model):
    _inherit = 'res.users'

    def __init__(self, pool, cr):
        init_res = super(Users, self).__init__(pool, cr)
        self.SELF_WRITEABLE_FIELDS = list(
            set(
                self.SELF_WRITEABLE_FIELDS +
                ['country_id', 'city', 'website', 'website_description', 'website_published']))
        return init_res

    create_date = fields.Datetime('Create Date', readonly=True, copy=False, select=True)
    karma = fields.Integer('Karma', default=0)
    badge_ids = fields.One2many('gamification.badge.user', 'user_id', string='Badges', copy=False)
    gold_badge = fields.Integer('Gold badges count', compute="_get_user_badge_level")
    silver_badge = fields.Integer('Silver badges count', compute="_get_user_badge_level")
    bronze_badge = fields.Integer('Bronze badges count', compute="_get_user_badge_level")

    @api.multi
    @api.depends('badge_ids')
    def _get_user_badge_level(self):
        """ Return total badge per level of users
        TDE CLEANME: shouldn't check type is forum ? """
        badge_groups = self.env['gamification.badge.user'].read_group(
            [('level', 'in', ['gold', 'silver', 'bronze'])],
            ['user_id', 'level', 'badge_id'],
            ['user_id', 'level'],
            lazy=False)
        badge_data = dict()
        for group in badge_groups:
            badge_data.setdefault(group['user_id'][0], dict())[group['level']] = group['__count']
        for user in self:
            user.gold_badge = badge_data.get(user.id) and badge_data[user.id].get('gold', 0) or 0
            user.silver_badge = badge_data.get(user.id) and badge_data[user.id].get('silver', 0) or 0
            user.bronze_badge = badge_data.get(user.id) and badge_data[user.id].get('bronze', 0) or 0

    @api.model
    def _generate_forum_token(self, user_id, email):
        """Return a token for email validation. This token is valid for the day
        and is a hash based on a (secret) uuid generated by the forum module,
        the user_id, the email and currently the day (to be updated if necessary). """
        forum_uuid = self.env['ir.config_parameter'].sudo().get_param('website_forum.uuid')
        return hashlib.sha256('%s-%s-%s-%s' % (
            datetime.now().replace(hour=0, minute=0, second=0, microsecond=0),
            forum_uuid,
            user_id,
            email)).hexdigest()

    @api.one
    def send_forum_validation_email(self, forum_id=None):
        if not self.email:
            return False
        token = self._generate_forum_token(self.id, self.email)
        activation_template = self.env.ref('website_forum.validation_email')
        if activation_template:
            params = {
                'token': token,
                'id': self.id,
                'email': self.email}
            if forum_id:
                params['forum_id'] = forum_id
            base_url = self.env['ir.config_parameter'].get_param('web.base.url')
            token_url = base_url + '/forum/validate_email?%s' % urlencode(params)
            activation_template.sudo().with_context(token_url=token_url).send_mail(self.id, force_send=True)
        return True

    @api.one
    def process_forum_validation_token(self, token, email, forum_id=None, context=None):
        validation_token = self._generate_forum_token(self.id, email)
        if token == validation_token and self.karma == 0:
            karma = 3
            forum = None
            if forum_id:
                forum = self.env['forum.forum'].browse(forum_id)
            else:
                forum_ids = self.env['forum.forum'].search([], limit=1)
                if forum_ids:
                    forum = forum_ids[0]
            if forum:
                # karma gained: karma to ask a question and have 2 downvotes
                karma = forum.karma_ask + (-2 * forum.karma_gen_question_downvote)
            return self.write({'karma': karma})
        return False

    @api.multi
    def add_karma(self, karma):
        for user in self:
            user.karma += karma
        return True

    @api.model
    def get_serialised_gamification_summary(self, excluded_categories=None):
        if isinstance(excluded_categories, list):
            if 'forum' not in excluded_categories:
                excluded_categories.append('forum')
        else:
            excluded_categories = ['forum']
        return super(Users, self).get_serialised_gamification_summary()
