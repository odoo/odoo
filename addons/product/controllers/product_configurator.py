# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo.http import Controller, request, route


class ProductConfiguratorController(Controller):

    @route('/product_configurator/get_values', type='json', auth='user')
    def get_product_configurator_values(
        self,
        product_template_id,
        company_id=None,
        ptav_ids=None,
        **kwargs
    ):
        """ Return all product information needed for the product configurator.

        :param int product_template_id: The product for which to seek information, as a
                                        `product.template` id.
        :param int|None company_id: The company to use, as a `res.company` id.
        :param recordset|None ptav_ids: The combination of the product, as a
                                        `product.template.attribute.value` recordset.
        :param dict kwargs: Optional data passed to helper methods.
        :rtype: dict
        :return: A dict containing a list of products information, generated by
                 :meth:`_get_product_information`.
        """
        if company_id:
            request.update_context(allowed_company_ids=[company_id])
        product_template = request.env['product.template'].browse(product_template_id)

        combination = request.env['product.template.attribute.value']
        if ptav_ids:
            combination = request.env['product.template.attribute.value'].browse(ptav_ids).filtered(
                lambda ptav: ptav.product_tmpl_id.id == product_template_id
            )
            # Set missing attributes (unsaved no_variant attributes, or new attribute on existing product)
            unconfigured_ptals = (
                product_template.attribute_line_ids - combination.attribute_line_id).filtered(
                lambda ptal: ptal.attribute_id.display_type != 'multi')
            combination += unconfigured_ptals.mapped(
                lambda ptal: ptal.product_template_value_ids._only_active()[:1]
            )
        if not combination:
            combination = product_template._get_first_possible_combination()

        return {
            "products": [
                dict(
                    **self._get_product_information(
                        product_template,
                        combination,
                        **kwargs
                    ),
                )
            ],
        }

    @route('/product_configurator/create_product', type='json', auth='user')
    def product_configurator_create_product(self, product_template_id, combination):
        """ Create the product when there is a dynamic attribute in the combination.

        :param int product_template_id: The product for which to seek information, as a
                                        `product.template` id.
        :param recordset combination: The combination of the product, as a
                                      `product.template.attribute.value` recordset.
        :rtype: int
        :return: The product created, as a `product.product` id.
        """
        product_template = request.env['product.template'].browse(product_template_id)
        combination = request.env['product.template.attribute.value'].browse(combination)
        product = product_template._create_product_variant(combination)
        return product.id

    @route('/product_configurator/update_combination', type='json', auth='user')
    def product_configurator_update_combination(
        self,
        product_template_id,
        combination,
        company_id=None,
        **kwargs
    ):
        """ Return the updated combination information.

        :param int product_template_id: The product for which to seek information, as a
                                        `product.template` id.
        :param recordset combination: The combination of the product, as a
                                      `product.template.attribute.value` recordset.
        :param int|None company_id: The company to use, as a `res.company` id.
        :param dict kwargs: Optional data passed to helper methods.
        :rtype: dict
        :return: Basic informations about a product, generated by
                 :meth:`_get_basic_product_information`.
        """
        if company_id:
            request.update_context(allowed_company_ids=[company_id])
        product_template = request.env['product.template'].browse(product_template_id)
        combination = request.env['product.template.attribute.value'].browse(combination)
        product = product_template._get_variant_for_combination(combination)

        return self._get_basic_product_information(
            product or product_template,
            combination,
            **kwargs
        )

    def _get_product_information(self, product_template, combination, parent_combination=None, **kwargs):
        """ Return complete information about a product.

        :param recordset product_template: The product for which to seek information, as a
                                           `product.template` record.
        :param recordset combination: The combination of the product, as a
                                      `product.template.attribute.value` recordset.
        :param dict kwargs: Optional data passed to helper methods.
        :rtype: dict
        :return: A dict with the following structure:
            {
                'product_tmpl_id': int,
                **self._get_basic_product_information(): See method's return for more info
                'attribute_line': [{
                    'id': int
                    'attribute': {
                        'id': int
                        'name': str
                        'display_type': str
                    },
                    'attribute_value': [{
                        'id': int,
                        'name': str,
                        'html_color': str|False,
                        'image': str|False,
                        'is_custom': bool,
                        **self._get_additional_attribute_values_information(): See method's return for more info,
                    }],
                    'selected_attribute_id': int,
                }],
                'exclusions': dict,
                'archived_combination': dict,
            }
        """
        product = product_template._get_variant_for_combination(combination)
        attribute_exclusions = product_template._get_attribute_exclusions(
            parent_combination=parent_combination,
            combination_ids=combination.ids,
        )

        return {
            'product_tmpl_id': product_template.id,
            **self._get_basic_product_information(
                product or product_template,
                combination,
                **kwargs
            ),
            'attribute_lines': [{
                'id': ptal.id,
                'attribute': dict(**ptal.attribute_id.read(['id', 'name', 'display_type'])[0]),
                'attribute_values': [
                    dict(
                        **ptav.read(['name', 'html_color', 'image', 'is_custom'])[0],
                        **self._get_additional_attribute_values_information(ptav, **kwargs),
                    )
                    for ptav in ptal.product_template_value_ids
                    if self._should_ptav_be_included_in_product_information(ptav, combination, **kwargs)
                ],
                'selected_attribute_value_ids': combination.filtered(
                    lambda c: ptal in c.attribute_line_id
                ).ids,
                'create_variant': ptal.attribute_id.create_variant,
            } for ptal in product_template.attribute_line_ids],
            'exclusions': attribute_exclusions['exclusions'],
            'archived_combinations': attribute_exclusions['archived_combinations'],
        }

    def _get_basic_product_information(self, product_or_template, combination, **kwargs):
        """ Return basic information about a product.

        :param recordset product_or_template: The product for which to seek information, as a
                                              `product.product` or `product.template` record.
        :param recordset combination: The combination of the product, as a
                                      `product.template.attribute.value` recordset.
        :param dict kwargs: Optional data passed to helper methods.
        :rtype: dict
        :return: A dict with the following structure::
            {
                'id': int,  # if `product_or_template` is a record of `product.product`.
                'description_sale': str|False,
                'display_name': str,
                'quantity': int,  # if `quantity` is defined in `kwargs`.
            }
        """
        basic_information = dict(
            **product_or_template.read(['description_sale', 'display_name'])[0]
        )
        # If the product is a template, check the combination to compute the name to take dynamic
        # and no_variant attributes into account. Also, drop the id which was auto-included by the
        # search but isn't relevant since it is supposed to be the id of a `product.product` record.
        if not product_or_template.is_product_variant:
            basic_information['id'] = False
            combination_name = combination._get_combination_name()
            if combination_name:
                basic_information.update(
                    display_name=f"{basic_information['display_name']} ({combination_name})"
                )
        quantity = kwargs.get('quantity')
        if quantity is not None:
            basic_information['quantity'] = quantity
        return dict(
            basic_information,
        )

    def _get_additional_attribute_values_information(self, ptav, **kwargs):
        """ Get additional information about attribute values.

        For a module to add additional information about attribute value, it must override this
        method and call super, then add the additional information.

        :param record ptav: The attribute value, as a `product.template.attribute.value` record.
        :return: The additional attribute values information.
        :rtype: dict
        """
        return {}

    def _should_ptav_be_included_in_product_information(self, ptav, combination, **kwargs):
        """ Return whether the ptav should be included in the product information.

        To be included in the product information, a ptav must be active.

        For a module to add more conditions to include the ptav in the product information, it must
        override this method and call super, then add the additional condition.

        :param record ptav: The attribute value, as a `product.template.attribute.value` record.
        :return: Whether to include the ptav in the product information.
        :rtype: Boolean
        """
        return ptav.ptav_active or combination and ptav.id in combination.ids
